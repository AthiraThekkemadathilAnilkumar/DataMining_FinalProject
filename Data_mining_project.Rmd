### Loading Packages

```{r}
f(!require(pacman))
  install.packages("pacman")

pacman::p_load(
  tidyverse,
  ggplot2,
  dplyr,
  arules,
  arulesViz,
  rCBA
)

```

### Loading Dataset

```{r}

pokemon <- read_csv("https://raw.githubusercontent.com/AthiraThekkemadathilAnilkumar/DataMining_FinalProject/main/Data/pokedex_(Update_05.20).csv")

```

```{r}

dim(pokemon)

```

```{r}

head(pokemon)

```

```{r}

str(pokemon)

```

### Data Pre-processing

### Removing the Pokemon which are not normal

```{r}

pokemon <- pokemon |>
  filter(!grepl("Mega ", name)) |>
  filter(!grepl("Ash-", name)) |>
  filter(!grepl("Zen Mode", name)) |>
  filter(!grepl("Partner", name)) |>
  filter(!grepl("Primal", name)) |>
  filter(!grepl("Crown", name)) |>
  filter(!grepl("Eternamax", name)) |>
  glimpse()

```

### Dimensionality of Dataset

```{r}

dim(pokemon)

```

### Printing the column names

```{r}

colnames(pokemon)

```

### Removing irrevalant column names

```{r}

pokemon <- pokemon |>
  select(-...1, 
         -japanese_name, 
         -german_name, 
         -base_friendship, 
         -ability_hidden,
         -abilities_number,
         -base_experience, 
         -egg_type_number,
         -egg_type_1,
         -egg_type_2,
         -percentage_male,
         -egg_cycles,
         -type_number)

colnames(pokemon)
```

```{r}

head(pokemon)

```

### Unique Values in Status Column

```{r}

unique(pokemon$status)

```

### Replacing the Sub-Legendary Values to Legendary Values

```{r}

pokemon$status <- ifelse(
  pokemon$status == "Sub Legendary", "Legendary", pokemon$status
)

```

```{r}

unique(pokemon$status)

```

### Checking NA Values

```{r}

colSums(is.na(pokemon))

```

### Data Exploration

### Visualizing the frequency for each status

```{r}

status_count <- table(pokemon$status)

status_data <- data.frame(
  Status = names(status_count), 
  Frequency = as.numeric(status_count)
)

print(status_data)

```

```{r}

ggplot(status_data, 
       aes(x = reorder(Status, - Frequency), 
           y = Frequency, 
           fill = Status)) + 
  geom_bar(stat =  "identity", width = 0.5) + 
  labs(
    title = "Frequency of PokÃ©mon",
    x = "Status",
    y = "Frequency"
  ) + 
  guides(fill = "none") +
  theme_minimal() + 
  coord_flip() + 
  theme(axis.text.x = element_text(hjust = 1)) + 
  scale_y_continuous(breaks = seq(0, 900, by = 100)) 

```

### Percentage ditribution

```{r}

pokemon_per <- prop.table(table(pokemon$status)) * 100

print(pokemon_per)

```

```{r warning=FALSE, error=FALSE, message=FALSE}

pokemon_growth_rate <- pokemon |>
  group_by(status, growth_rate) |>
  summarise(percentages = n()) |>
  group_by(status) |>
  mutate(percentages = (percentages / sum(percentages)) * 100) |>
  mutate(percentages = round(percentages, 2)) |>
  rename(growth_rate = growth_rate)

```

```{r}

print(pokemon_growth_rate)

```

```{r}

ggplot(pokemon_growth_rate, 
       aes(x = status, y = percentages, fill = as.factor(growth_rate))) +
  geom_bar(stat = "identity", position = "stack", width = 0.5) +
  guides(fill = "none") +
  labs(title = "Distribution of growth rate", 
       x = "Status", 
       y = "Percentages") +
  theme_minimal()
  
```

### Total Point Distribution

```{r}

ggplot(pokemon, aes(x = status, y = total_points)) + 
  geom_boxplot(aes(fill = status)) + 
  guides(fill = "none") + 
  labs(title = "Distribution of Total Points", 
       x = "Status", 
       y = "Total Points") +
  theme_minimal()

```

### Catch Rate Distribution

```{r warning=FALSE, error=FALSE, message=FALSE}

ggplot(pokemon, 
       aes(x = status, y = catch_rate, fill = status)) + 
  geom_boxplot() +
  guides(fill = "none") +
  labs(
    title = "Distribution of catch rate", 
    x = "Status", 
    y = "Catch Rate"
  ) + 
  theme_minimal()

```

### Distribution of Weight

```{r}

ggplot(pokemon, aes(x = weight_kg, y = status, fill = status)) +
  geom_boxplot() +
  labs(title = "Distribution of Weight (KG)", 
       x = "Weight (KG)", 
       y = "Status") +
  guides(fill = "none") +
  theme_minimal()

```

### Distribution of Height

```{r}

ggplot(pokemon, aes(x = status, y = height_m, fill = status)) +
  geom_boxplot() +
  labs(title = "Distribution of Height (M)", 
       x = "Status", y = "Height (M)") +
  guides(fill = "none") +
  theme_minimal()

```

### Correlation between Height and Weight

```{r}

correlation_matrix <- cor(pokemon[c("height_m", "weight_kg")])

print(correlation_matrix)

```

```{r}

ggplot(pokemon, aes(x = height_m, y = weight_kg, 
                    color = status)) +
  geom_point() +
  labs(title = "Scatter plot of Height vs Weight by status", 
       x = "Height (m)", y = "Weight (kg)") +
  theme_minimal() 

```

## Data Mining 

### Association rule 

```{r}
# Discretization of continuous variables
pokemon$TotalPoints_binned <- cut(pokemon$total_points, breaks = 3, labels = c("Low", "Medium", "High"))
pokemon$CatchRate_category <- cut(pokemon$catch_rate, breaks = c(0, 50, 100, 255), labels = c("Low", "Medium", "High"))

# Define bins for Weight and Height based on quartiles (you can customize these)
weight_bins <- quantile(pokemon$weight_kg, probs = c(0, 0.33, 0.66, 1), na.rm = TRUE)
height_bins <- quantile(pokemon$height_m, probs = c(0, 0.33, 0.66, 1), na.rm = TRUE)
pokemon$WeightCategory <- cut(pokemon$weight_kg, breaks = weight_bins, labels = c("Light", "Medium", "Heavy"))
pokemon$HeightCategory <- cut(pokemon$height_m, breaks = height_bins, labels = c("Short", "Medium", "Tall"))
```

```{r}
#Select relevant columns for association rule mining
selected_data <- pokemon[, c("TotalPoints_binned", "CatchRate_category", "WeightCategory", "HeightCategory", "status")]

# Convert the data to transactions format
trans_data <- as(selected_data, "transactions")

# Apply association rule mining (using Apriori algorithm)
association_rules <- apriori(trans_data, 
                             parameter = list(support = 0.1, confidence = 0.7), 
                             control = list(verbose = TRUE))

```

```{r}
# Show the generated association rules
inspect(association_rules)
```
```{r}
# Apply association rule mining using FP-Growth algorithm
fp_growth_rules <- fpgrowth(trans_data, 
                            parameter = list(support = 0.1, confidence = 0.5),
                            control = list(verbose = TRUE))
```

